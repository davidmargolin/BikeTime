(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.mapboxSdk = factory());
}(this, (function () { 'use strict';

  // Like https://github.com/thlorenz/lib/parse-link-header but without any
  // additional dependencies.

  function parseParam(param) {
    var parts = param.match(/\s*(.+)\s*=\s*"?([^"]+)"?/);
    if (!parts) return null;

    return {
      key: parts[1],
      value: parts[2]
    };
  }

  function parseLink(link) {
    var parts = link.match(/<?([^>]*)>(.*)/);
    if (!parts) return null;

    var linkUrl = parts[1];
    var linkParams = parts[2].split(';');
    var rel = null;
    var parsedLinkParams = linkParams.reduce(function(result, param) {
      var parsed = parseParam(param);
      if (!parsed) return result;
      if (parsed.key === 'rel') {
        if (!rel) {
          rel = parsed.value;
        }
        return result;
      }
      result[parsed.key] = parsed.value;
      return result;
    }, {});
    if (!rel) return null;

    return {
      url: linkUrl,
      rel: rel,
      params: parsedLinkParams
    };
  }

  /**
   * Parse a Link header.
   *
   * @param {string} linkHeader
   * @returns {{
   *   [string]: {
   *     url: string,
   *     params: { [string]: string }
   *   }
   * }}
   */
  function parseLinkHeader(linkHeader) {
    if (!linkHeader) return {};

    return linkHeader.split(/,\s*</).reduce(function(result, link) {
      var parsed = parseLink(link);
      if (!parsed) return result;
      // rel value can be multiple whitespace-separated rels.
      var splitRel = parsed.rel.split(/\s+/);
      splitRel.forEach(function(rel) {
        if (!result[rel]) {
          result[rel] = {
            url: parsed.url,
            params: parsed.params
          };
        }
      });
      return result;
    }, {});
  }

  var parseLinkHeader_1 = parseLinkHeader;

  /**
   * A Mapbox API response.
   *
   * @class MapiResponse
   * @property {Object} body - The response body, parsed as JSON.
   * @property {string} rawBody - The raw response body.
   * @property {number} statusCode - The response's status code.
   * @property {Object} headers - The parsed response headers.
   * @property {Object} links - The parsed response links.
   * @property {MapiRequest} request - The response's originating `MapiRequest`.
   */

  /**
   * @ignore
   * @param {MapiRequest} request
   * @param {Object} responseData
   * @param {Object} responseData.headers
   * @param {string} responseData.body
   * @param {number} responseData.statusCode
   */
  function MapiResponse(request, responseData) {
    this.request = request;
    this.headers = responseData.headers;
    this.rawBody = responseData.body;
    this.statusCode = responseData.statusCode;
    try {
      this.body = JSON.parse(responseData.body || '{}');
    } catch (parseError) {
      this.body = responseData.body;
    }
    this.links = parseLinkHeader_1(this.headers.link);
  }

  /**
   * Check if there is a next page that you can fetch.
   *
   * @returns {boolean}
   */
  MapiResponse.prototype.hasNextPage = function hasNextPage() {
    return !!this.links.next;
  };

  /**
   * Create a request for the next page, if there is one.
   * If there is no next page, returns `null`.
   *
   * @returns {MapiRequest | null}
   */
  MapiResponse.prototype.nextPage = function nextPage() {
    if (!this.hasNextPage()) return null;
    return this.request._extend({
      path: this.links.next.url
    });
  };

  var mapiResponse = MapiResponse;

  var constants = {
    API_ORIGIN: 'https://api.mapbox.com',
    EVENT_PROGRESS_DOWNLOAD: 'downloadProgress',
    EVENT_PROGRESS_UPLOAD: 'uploadProgress',
    EVENT_ERROR: 'error',
    EVENT_RESPONSE: 'response',
    ERROR_HTTP: 'HttpError',
    ERROR_REQUEST_ABORTED: 'RequestAbortedError'
  };

  /**
   * A Mapbox API error.
   *
   * If there's an error during the API transaction,
   * the Promise returned by `MapiRequest`'s [`send`](#send)
   * method should reject with a `MapiError`.
   *
   * @class MapiError
   * @hideconstructor
   * @property {MapiRequest} request - The errored request.
   * @property {string} type - The type of error. Usually this is `'HttpError'`.
   *   If the request was aborted, so the error was
   *   not sent from the server, the type will be
   *   `'RequestAbortedError'`.
   * @property {number} [statusCode] - The numeric status code of
   *   the HTTP response.
   * @property {Object | string} [body] - If the server sent a response body,
   *   this property exposes that response, parsed as JSON if possible.
   * @property {string} [message] - Whatever message could be derived from the
   *   call site and HTTP response.
   *
   * @param {MapiRequest} options.request
   * @param {number} [options.statusCode]
   * @param {string} [options.body]
   * @param {string} [options.message]
   * @param {string} [options.type]
   */
  function MapiError(options) {
    var errorType = options.type || constants.ERROR_HTTP;

    var body;
    if (options.body) {
      try {
        body = JSON.parse(options.body);
      } catch (e) {
        body = options.body;
      }
    } else {
      body = null;
    }

    var message = options.message || null;
    if (!message) {
      if (typeof body === 'string') {
        message = body;
      } else if (body && typeof body.message === 'string') {
        message = body.message;
      } else if (errorType === constants.ERROR_REQUEST_ABORTED) {
        message = 'Request aborted';
      }
    }

    this.message = message;
    this.type = errorType;
    this.statusCode = options.statusCode || null;
    this.request = options.request;
    this.body = body;
  }

  var mapiError = MapiError;

  function parseSingleHeader(raw) {
    var boundary = raw.indexOf(':');
    var name = raw
      .substring(0, boundary)
      .trim()
      .toLowerCase();
    var value = raw.substring(boundary + 1).trim();
    return {
      name: name,
      value: value
    };
  }

  /**
   * Parse raw headers into an object with lowercase properties.
   * Does not fully parse headings into more complete data structure,
   * as larger libraries might do. Also does not deal with duplicate
   * headers because Node doesn't seem to deal with those well, so
   * we shouldn't let the browser either, for consistency.
   *
   * @param {string} raw
   * @returns {Object}
   */
  function parseHeaders(raw) {
    var headers = {};
    if (!raw) {
      return headers;
    }

    raw
      .trim()
      .split(/[\r|\n]+/)
      .forEach(function(rawHeader) {
        var parsed = parseSingleHeader(rawHeader);
        headers[parsed.name] = parsed.value;
      });

    return headers;
  }

  var parseHeaders_1 = parseHeaders;

  // Keys are request IDs, values are XHRs.
  var requestsUnderway = {};

  function browserAbort(request) {
    var xhr = requestsUnderway[request.id];
    if (!xhr) return;
    xhr.abort();
    delete requestsUnderway[request.id];
  }

  function createResponse(request, xhr) {
    return new mapiResponse(request, {
      body: xhr.response,
      headers: parseHeaders_1(xhr.getAllResponseHeaders()),
      statusCode: xhr.status
    });
  }

  function normalizeBrowserProgressEvent(event) {
    var total = event.total;
    var transferred = event.loaded;
    var percent = 100 * transferred / total;
    return {
      total: total,
      transferred: transferred,
      percent: percent
    };
  }

  function sendRequestXhr(request, xhr) {
    return new Promise(function(resolve, reject) {
      xhr.onprogress = function(event) {
        request.emitter.emit(
          constants.EVENT_PROGRESS_DOWNLOAD,
          normalizeBrowserProgressEvent(event)
        );
      };

      xhr.upload.onprogress = function(event) {
        request.emitter.emit(
          constants.EVENT_PROGRESS_UPLOAD,
          normalizeBrowserProgressEvent(event)
        );
      };

      xhr.onerror = function(error) {
        reject(error);
      };

      xhr.onabort = function() {
        var mapiError$$1 = new mapiError({
          request: request,
          type: constants.ERROR_REQUEST_ABORTED
        });
        reject(mapiError$$1);
      };

      xhr.onload = function() {
        delete requestsUnderway[request.id];
        if (xhr.status < 200 || xhr.status >= 400) {
          var mapiError$$1 = new mapiError({
            request: request,
            body: xhr.response,
            statusCode: xhr.status
          });
          reject(mapiError$$1);
          return;
        }
        resolve(xhr);
      };

      var body = request.body;
      var file = request.file;

      // matching service needs to send a www-form-urlencoded request
      if (typeof body === 'string') {
        xhr.send(body);
      } else if (body) {
        xhr.send(JSON.stringify(body));
      } else if (file) {
        xhr.send(file);
      } else {
        xhr.send();
      }

      requestsUnderway[request.id] = xhr;
    }).then(function(xhr) {
      return createResponse(request, xhr);
    });
  }

  // The accessToken argument gives this function flexibility
  // for Mapbox's internal client.
  function createRequestXhr(request, accessToken) {
    var url = request.url(accessToken);
    var xhr = new window.XMLHttpRequest();
    xhr.open(request.method, url);
    if (request.headers) {
      Object.keys(request.headers).forEach(function(key) {
        xhr.setRequestHeader(key, request.headers[key]);
      });
    }
    return xhr;
  }

  function browserSend(request) {
    return Promise.resolve().then(function() {
      var xhr = createRequestXhr(request, request.client.accessToken);
      return sendRequestXhr(request, xhr);
    });
  }

  var browserLayer = {
    browserAbort: browserAbort,
    sendRequestXhr: sendRequestXhr,
    browserSend: browserSend,
    createRequestXhr: createRequestXhr
  };

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var base64 = createCommonjsModule(function (module, exports) {
  (function(root) {

  	// Detect free variables `exports`.
  	var freeExports = exports;

  	// Detect free variable `module`.
  	var freeModule = module &&
  		module.exports == freeExports && module;

  	// Detect free variable `global`, from Node.js or Browserified code, and use
  	// it as `root`.
  	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;
  	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
  		root = freeGlobal;
  	}

  	/*--------------------------------------------------------------------------*/

  	var InvalidCharacterError = function(message) {
  		this.message = message;
  	};
  	InvalidCharacterError.prototype = new Error;
  	InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  	var error = function(message) {
  		// Note: the error messages used throughout this file match those used by
  		// the native `atob`/`btoa` implementation in Chromium.
  		throw new InvalidCharacterError(message);
  	};

  	var TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  	// http://whatwg.org/html/common-microsyntaxes.html#space-character
  	var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g;

  	// `decode` is designed to be fully compatible with `atob` as described in the
  	// HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob
  	// The optimized base64-decoding algorithm used is based on @atk’s excellent
  	// implementation. https://gist.github.com/atk/1020396
  	var decode = function(input) {
  		input = String(input)
  			.replace(REGEX_SPACE_CHARACTERS, '');
  		var length = input.length;
  		if (length % 4 == 0) {
  			input = input.replace(/==?$/, '');
  			length = input.length;
  		}
  		if (
  			length % 4 == 1 ||
  			// http://whatwg.org/C#alphanumeric-ascii-characters
  			/[^+a-zA-Z0-9/]/.test(input)
  		) {
  			error(
  				'Invalid character: the string to be decoded is not correctly encoded.'
  			);
  		}
  		var bitCounter = 0;
  		var bitStorage;
  		var buffer;
  		var output = '';
  		var position = -1;
  		while (++position < length) {
  			buffer = TABLE.indexOf(input.charAt(position));
  			bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;
  			// Unless this is the first of a group of 4 characters…
  			if (bitCounter++ % 4) {
  				// …convert the first 8 bits to a single ASCII character.
  				output += String.fromCharCode(
  					0xFF & bitStorage >> (-2 * bitCounter & 6)
  				);
  			}
  		}
  		return output;
  	};

  	// `encode` is designed to be fully compatible with `btoa` as described in the
  	// HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa
  	var encode = function(input) {
  		input = String(input);
  		if (/[^\0-\xFF]/.test(input)) {
  			// Note: no need to special-case astral symbols here, as surrogates are
  			// matched, and the input is supposed to only contain ASCII anyway.
  			error(
  				'The string to be encoded contains characters outside of the ' +
  				'Latin1 range.'
  			);
  		}
  		var padding = input.length % 3;
  		var output = '';
  		var position = -1;
  		var a;
  		var b;
  		var c;
  		var buffer;
  		// Make sure any padding is handled outside of the loop.
  		var length = input.length - padding;

  		while (++position < length) {
  			// Read three bytes, i.e. 24 bits.
  			a = input.charCodeAt(position) << 16;
  			b = input.charCodeAt(++position) << 8;
  			c = input.charCodeAt(++position);
  			buffer = a + b + c;
  			// Turn the 24 bits into four chunks of 6 bits each, and append the
  			// matching character for each of them to the output.
  			output += (
  				TABLE.charAt(buffer >> 18 & 0x3F) +
  				TABLE.charAt(buffer >> 12 & 0x3F) +
  				TABLE.charAt(buffer >> 6 & 0x3F) +
  				TABLE.charAt(buffer & 0x3F)
  			);
  		}

  		if (padding == 2) {
  			a = input.charCodeAt(position) << 8;
  			b = input.charCodeAt(++position);
  			buffer = a + b;
  			output += (
  				TABLE.charAt(buffer >> 10) +
  				TABLE.charAt((buffer >> 4) & 0x3F) +
  				TABLE.charAt((buffer << 2) & 0x3F) +
  				'='
  			);
  		} else if (padding == 1) {
  			buffer = input.charCodeAt(position);
  			output += (
  				TABLE.charAt(buffer >> 2) +
  				TABLE.charAt((buffer << 4) & 0x3F) +
  				'=='
  			);
  		}

  		return output;
  	};

  	var base64 = {
  		'encode': encode,
  		'decode': decode,
  		'version': '0.1.0'
  	};

  	// Some AMD build optimizers, like r.js, check for specific condition patterns
  	// like the following:
  	if (
  		typeof undefined == 'function' &&
  		typeof undefined.amd == 'object' &&
  		undefined.amd
  	) {
  		undefined(function() {
  			return base64;
  		});
  	}	else if (freeExports && !freeExports.nodeType) {
  		if (freeModule) { // in Node.js or RingoJS v0.8.0+
  			freeModule.exports = base64;
  		} else { // in Narwhal or RingoJS v0.7.0-
  			for (var key in base64) {
  				base64.hasOwnProperty(key) && (freeExports[key] = base64[key]);
  			}
  		}
  	} else { // in Rhino or a web browser
  		root.base64 = base64;
  	}

  }(commonjsGlobal));
  });

  var tokenCache = {};

  function parseToken(token) {
    if (tokenCache[token]) {
      return tokenCache[token];
    }

    var parts = token.split('.');
    var usage = parts[0];
    var rawPayload = parts[1];
    if (!rawPayload) {
      throw new Error('Invalid token');
    }

    var parsedPayload = parsePaylod(rawPayload);

    var result = {
      usage: usage,
      user: parsedPayload.u
    };
    if (has(parsedPayload, 'a')) result.authorization = parsedPayload.a;
    if (has(parsedPayload, 'exp')) result.expires = parsedPayload.exp * 1000;
    if (has(parsedPayload, 'iat')) result.created = parsedPayload.iat * 1000;
    if (has(parsedPayload, 'scopes')) result.scopes = parsedPayload.scopes;
    if (has(parsedPayload, 'client')) result.client = parsedPayload.client;
    if (has(parsedPayload, 'll')) result.lastLogin = parsedPayload.ll;
    if (has(parsedPayload, 'iu')) result.impersonator = parsedPayload.iu;

    tokenCache[token] = result;
    return result;
  }

  function parsePaylod(rawPayload) {
    try {
      return JSON.parse(base64.decode(rawPayload));
    } catch (parseError) {
      throw new Error('Invalid token');
    }
  }

  function has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  var parseMapboxToken = parseToken;

  var immutable = extend;

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function extend() {
      var target = {};

      for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
              }
          }
      }

      return target
  }

  var eventemitter3 = createCommonjsModule(function (module) {

  var has = Object.prototype.hasOwnProperty
    , prefix = '~';

  /**
   * Constructor to create a storage for our `EE` objects.
   * An `Events` instance is a plain object whose properties are event names.
   *
   * @constructor
   * @private
   */
  function Events() {}

  //
  // We try to not inherit from `Object.prototype`. In some engines creating an
  // instance in this way is faster than calling `Object.create(null)` directly.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // character to make sure that the built-in object properties are not
  // overridden or used as an attack vector.
  //
  if (Object.create) {
    Events.prototype = Object.create(null);

    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
  }

  /**
   * Representation of a single event listener.
   *
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
   * @constructor
   * @private
   */
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }

  /**
   * Add a listener for a given event.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} once Specify if the listener is a one-time listener.
   * @returns {EventEmitter}
   * @private
   */
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
      throw new TypeError('The listener must be a function');
    }

    var listener = new EE(fn, context || emitter, once)
      , evt = prefix ? prefix + event : event;

    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];

    return emitter;
  }

  /**
   * Clear event by name.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} evt The Event name.
   * @private
   */
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }

  /**
   * Minimal `EventEmitter` interface that is molded against the Node.js
   * `EventEmitter` interface.
   *
   * @constructor
   * @public
   */
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }

  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   *
   * @returns {Array}
   * @public
   */
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = []
      , events
      , name;

    if (this._eventsCount === 0) return names;

    for (name in (events = this._events)) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }

    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }

    return names;
  };

  /**
   * Return the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Array} The registered listeners.
   * @public
   */
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event
      , handlers = this._events[evt];

    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];

    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }

    return ee;
  };

  /**
   * Return the number of listeners listening to a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Number} The number of listeners.
   * @public
   */
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event
      , listeners = this._events[evt];

    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };

  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Boolean} `true` if the event had listeners, else `false`.
   * @public
   */
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;

    if (!this._events[evt]) return false;

    var listeners = this._events[evt]
      , len = arguments.length
      , args
      , i;

    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

      switch (len) {
        case 1: return listeners.fn.call(listeners.context), true;
        case 2: return listeners.fn.call(listeners.context, a1), true;
        case 3: return listeners.fn.call(listeners.context, a1, a2), true;
        case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }

      for (i = 1, args = new Array(len -1); i < len; i++) {
        args[i - 1] = arguments[i];
      }

      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length
        , j;

      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

        switch (len) {
          case 1: listeners[i].fn.call(listeners[i].context); break;
          case 2: listeners[i].fn.call(listeners[i].context, a1); break;
          case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
          case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
          default:
            if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
              args[j - 1] = arguments[j];
            }

            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }

    return true;
  };

  /**
   * Add a listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };

  /**
   * Add a one-time listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };

  /**
   * Remove the listeners of a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn Only remove the listeners that match this function.
   * @param {*} context Only remove the listeners that have this context.
   * @param {Boolean} once Only remove one-time listeners.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;

    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }

    var listeners = this._events[evt];

    if (listeners.fn) {
      if (
        listeners.fn === fn &&
        (!once || listeners.once) &&
        (!context || listeners.context === context)
      ) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (
          listeners[i].fn !== fn ||
          (once && !listeners[i].once) ||
          (context && listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }

      //
      // Reset the array, or remove it completely if we have no more listeners.
      //
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }

    return this;
  };

  /**
   * Remove all listeners, or those of the specified event.
   *
   * @param {(String|Symbol)} [event] The event name.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;

    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }

    return this;
  };

  //
  // Alias methods names because people roll like that.
  //
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  //
  // Expose the prefix.
  //
  EventEmitter.prefixed = prefix;

  //
  // Allow `EventEmitter` to be imported as module namespace.
  //
  EventEmitter.EventEmitter = EventEmitter;

  //
  // Expose the module.
  //
  {
    module.exports = EventEmitter;
  }
  });

  // Encode each item of an array individually. The comma
  // delimiters should not themselves be encoded.
  function encodeArray(arrayValue) {
    return arrayValue.map(encodeURIComponent).join(',');
  }

  function encodeValue(value) {
    if (Array.isArray(value)) {
      return encodeArray(value);
    }
    return encodeURIComponent(String(value));
  }

  /**
   * Append a query parameter to a URL.
   *
   * @param {string} url
   * @param {string} key
   * @param {string|number|boolean|Array<*>>} [value] - Provide an array
   *   if the value is a list and commas between values need to be
   *   preserved, unencoded.
   * @returns {string} - Modified URL.
   */
  function appendQueryParam(url, key, value) {
    if (value === false || value === null) {
      return url;
    }
    var punctuation = /\?/.test(url) ? '&' : '?';
    var query = encodeURIComponent(key);
    if (value !== undefined && value !== '' && value !== true) {
      query += '=' + encodeValue(value);
    }
    return '' + url + punctuation + query;
  }

  /**
   * Derive a query string from an object and append it
   * to a URL.
   *
   * @param {string} url
   * @param {Object} [queryObject] - Values should be primitives.
   * @returns {string} - Modified URL.
   */
  function appendQueryObject(url, queryObject) {
    if (!queryObject) {
      return url;
    }

    var result = url;
    Object.keys(queryObject).forEach(function(key) {
      var value = queryObject[key];
      if (value === undefined) {
        return;
      }
      if (Array.isArray(value)) {
        value = value
          .filter(function(v) {
            return !!v;
          })
          .join(',');
      }
      result = appendQueryParam(result, key, value);
    });
    return result;
  }

  /**
   * Prepend an origin to a URL. If the URL already has an
   * origin, do nothing.
   *
   * @param {string} url
   * @param {string} origin
   * @returns {string} - Modified URL.
   */
  function prependOrigin(url, origin) {
    if (!origin) {
      return url;
    }

    if (url.slice(0, 4) === 'http') {
      return url;
    }

    var delimiter = url[0] === '/' ? '' : '/';
    return '' + origin.replace(/\/$/, '') + delimiter + url;
  }

  /**
   * Interpolate values into a route with express-style,
   * colon-prefixed route parameters.
   *
   * @param {string} route
   * @param {Object} [params] - Values should be primitives
   *   or arrays of primitives. Provide an array if the value
   *   is a list and commas between values need to be
   *   preserved, unencoded.
   * @returns {string} - Modified URL.
   */
  function interpolateRouteParams(route, params) {
    if (!params) {
      return route;
    }
    return route.replace(/\/:([a-zA-Z0-9]+)/g, function(_, paramId) {
      var value = params[paramId];
      if (value === undefined) {
        throw new Error('Unspecified route parameter ' + paramId);
      }
      var preppedValue = encodeValue(value);
      return '/' + preppedValue;
    });
  }

  var urlUtils = {
    appendQueryObject: appendQueryObject,
    appendQueryParam: appendQueryParam,
    prependOrigin: prependOrigin,
    interpolateRouteParams: interpolateRouteParams
  };

  var requestId = 1;

  /**
   * A Mapbox API request.
   *
   * Note that creating a `MapiRequest` does *not* send the request automatically.
   * Use the request's `send` method to send it off and get a `Promise`.
   *
   * The `emitter` property is an `EventEmitter` that emits the following events:
   *
   * - `'response'` - Listeners will be called with a `MapiResponse`.
   * - `'error'` - Listeners will be called with a `MapiError`.
   * - `'downloadProgress'` - Listeners will be called with `ProgressEvents`.
   * - `'uploadProgress'` - Listeners will be called with `ProgressEvents`.
   *
   * @class MapiRequest
   * @property {EventEmitter} emitter - An event emitter. See above.
   * @property {MapiClient} client - This request's `MapiClient`.
   * @property {MapiResponse|null} response - If this request has been sent and received
   *   a response, the response is available on this property.
   * @property {MapiError|Error|null} error - If this request has been sent and
   *   received an error in response, the error is available on this property.
   * @property {boolean} aborted - If the request has been aborted
   *   (via [`abort`](#abort)), this property will be `true`.
   * @property {boolean} sent - If the request has been sent, this property will
   *   be `true`. You cannot send the same request twice, so if you need to create
   *   a new request that is the equivalent of an existing one, use
   *   [`clone`](#clone).
   * @property {string} path - The request's path, including colon-prefixed route
   *   parameters.
   * @property {string} origin - The request's origin.
   * @property {string} method - The request's HTTP method.
   * @property {Object} query - A query object, which will be transformed into
   *   a URL query string.
   * @property {Object} params - A route parameters object, whose values will
   *   be interpolated the path.
   * @property {Object} headers - The request's headers,
   * @property {Object|string|null} body - Data to send with the request.
   *   If the request has a body, it will also be sent with the header
   *   `'Content-Type: application/json'`.
   * @property {Blob|ArrayBuffer|string|ReadStream} file - A file to
   *   send with the request. The browser client accepts Blobs and ArrayBuffers;
   *   the Node client accepts strings (filepaths) and ReadStreams.
   */

  /**
   * @ignore
   * @param {MapiClient} client
   * @param {Object} options
   * @param {string} options.method
   * @param {string} options.path
   * @param {Object} [options.query={}]
   * @param {Object} [options.params={}]
   * @param {string} [options.origin]
   * @param {Object} [options.headers]
   * @param {Object} [options.body=null]
   * @param {Blob|ArrayBuffer|string|ReadStream} [options.file=null]
   */
  function MapiRequest(client, options) {
    if (!client) {
      throw new Error('MapiRequest requires a client');
    }
    if (!options || !options.path || !options.method) {
      throw new Error(
        'MapiRequest requires an options object with path and method properties'
      );
    }

    var defaultHeaders = {};
    if (options.body) {
      defaultHeaders['content-type'] = 'application/json';
    }

    var headersWithDefaults = immutable(defaultHeaders, options.headers);

    // Disallows duplicate header names of mixed case,
    // e.g. Content-Type and content-type.
    var headers = Object.keys(headersWithDefaults).reduce(function(memo, name) {
      memo[name.toLowerCase()] = headersWithDefaults[name];
      return memo;
    }, {});

    this.id = requestId++;
    this._options = options;

    this.emitter = new eventemitter3();
    this.client = client;
    this.response = null;
    this.error = null;
    this.sent = false;
    this.aborted = false;
    this.path = options.path;
    this.method = options.method;
    this.origin = options.origin || client.origin;
    this.query = options.query || {};
    this.params = options.params || {};
    this.body = options.body || null;
    this.file = options.file || null;
    this.headers = headers;
  }

  /**
   * Get the URL of the request.
   *
   * @param {string} [accessToken] - By default, the access token of the request's
   *   client is used.
   * @return {string}
   */
  MapiRequest.prototype.url = function url(accessToken) {
    var url = urlUtils.prependOrigin(this.path, this.origin);
    url = urlUtils.appendQueryObject(url, this.query);
    var routeParams = this.params;
    if (accessToken) {
      url = urlUtils.appendQueryParam(url, 'access_token', accessToken);
      var accessTokenOwnerId = parseMapboxToken(accessToken).user;
      routeParams = immutable({ ownerId: accessTokenOwnerId }, routeParams);
    }
    url = urlUtils.interpolateRouteParams(url, routeParams);
    return url;
  };

  /**
   * Send the request. Returns a Promise that resolves with a `MapiResponse`.
   * You probably want to use `response.body`.
   *
   * `send` only retrieves the first page of paginated results. You can get
   * the next page by using the `MapiResponse`'s [`nextPage`](#nextpage)
   * function, or iterate through all pages using [`eachPage`](#eachpage)
   * instead of `send`.
   *
   * @returns {Promise<MapiResponse>}
   */
  MapiRequest.prototype.send = function send() {
    var self = this;

    if (self.sent) {
      throw new Error(
        'This request has already been sent. Check the response and error properties. Create a new request with clone().'
      );
    }
    self.sent = true;

    return self.client.sendRequest(self).then(
      function(response) {
        self.response = response;
        self.emitter.emit(constants.EVENT_RESPONSE, response);
        return response;
      },
      function(error) {
        self.error = error;
        self.emitter.emit(constants.EVENT_ERROR, error);
        throw error;
      }
    );
  };

  /**
   * Abort the request.
   *
   * Any pending `Promise` returned by [`send`](#send) will be rejected with
   * an error with `type: 'RequestAbortedError'`. If you've created a request
   * that might be aborted, you need to catch and handle such errors.
   *
   * This method will also abort any requests created while fetching subsequent
   * pages via [`eachPage`](#eachpage).
   *
   * If the request has not been sent or has already been aborted, nothing
   * will happen.
   */
  MapiRequest.prototype.abort = function abort() {
    if (this._nextPageRequest) {
      this._nextPageRequest.abort();
      delete this._nextPageRequest;
    }

    if (this.response || this.error || this.aborted) return;

    this.aborted = true;
    this.client.abortRequest(this);
  };

  /**
   * Invoke a callback for each page of a paginated API response.
   *
   * The callback should have the following signature:
   *
   * ```js
   * (
   *   error: MapiError,
   *   response: MapiResponse,
   *   next: () => void
   * ) => void
   * ```
   *
   * **The next page will not be fetched until you've invoked the
   * `next` callback**, indicating that you're ready for it.
   *
   * @param {Function} callback
   */
  MapiRequest.prototype.eachPage = function eachPage(callback) {
    var self = this;

    function handleResponse(response) {
      function getNextPage() {
        delete self._nextPageRequest;
        var nextPageRequest = response.nextPage();
        if (nextPageRequest) {
          self._nextPageRequest = nextPageRequest;
          getPage(nextPageRequest);
        }
      }
      callback(null, response, getNextPage);
    }

    function handleError(error) {
      callback(error, null, function() {});
    }

    function getPage(request) {
      request.send().then(handleResponse, handleError);
    }
    getPage(this);
  };

  /**
   * Clone this request.
   *
   * Each request can only be sent *once*. So if you'd like to send the
   * same request again, clone it and send away.
   *
   * @returns {MapiRequest} - A new `MapiRequest` configured just like this one.
   */
  MapiRequest.prototype.clone = function clone() {
    return this._extend();
  };

  /**
   * @ignore
   */
  MapiRequest.prototype._extend = function _extend(options) {
    var extendedOptions = immutable(this._options, options);
    return new MapiRequest(this.client, extendedOptions);
  };

  var mapiRequest = MapiRequest;

  /**
   * A low-level Mapbox API client. Use it to create service clients
   * that share the same configuration.
   *
   * Services and `MapiRequest`s use the underlying `MapiClient` to
   * determine how to create, send, and abort requests in a way
   * that is appropriate to the configuration and environment
   * (Node or the browser).
   *
   * @class MapiClient
   * @property {string} accessToken - The Mapbox access token assigned
   *   to this client.
   */

  function MapiClient(options) {
    if (!options || !options.accessToken) {
      throw new Error('Cannot create a client without an access token');
    }
    // Try parsing the access token to determine right away if it's valid.
    parseMapboxToken(options.accessToken);

    this.accessToken = options.accessToken;
    this.origin = options.origin || constants.API_ORIGIN;
  }

  MapiClient.prototype.createRequest = function createRequest(requestOptions) {
    return new mapiRequest(this, requestOptions);
  };

  var mapiClient = MapiClient;

  function BrowserClient(options) {
    mapiClient.call(this, options);
  }
  BrowserClient.prototype = Object.create(mapiClient.prototype);
  BrowserClient.prototype.constructor = BrowserClient;

  BrowserClient.prototype.sendRequest = browserLayer.browserSend;
  BrowserClient.prototype.abortRequest = browserLayer.browserAbort;

  /**
   * Create a client for the browser.
   *
   * @param {Object} options
   * @param {string} options.accessToken
   * @param {string} [options.origin]
   * @returns {MapiClient}
   */
  function createBrowserClient(options) {
    return new BrowserClient(options);
  }

  var browserClient = createBrowserClient;

  var toString = Object.prototype.toString;

  var isPlainObj = function (x) {
  	var prototype;
  	return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
  };

  /**
   * Validators are functions which assert certain type.
   * They can return a string which can then be used
   * to display a helpful error message.
   * They can also return a function for a custom error message.
   */



  var v = {};

  /**
   * Runners
   *
   * Take root validators and run assertion
   */
  v.assert = function(rootValidator, options) {
    options = options || {};
    return function(value) {
      var message = validate(rootValidator, value);
      // all good
      if (!message) {
        return;
      }

      var errorMessage = processMessage(message, options);

      if (options.apiName) {
        errorMessage = options.apiName + ': ' + errorMessage;
      }

      throw new Error(errorMessage);
    };
  };

  /**
   * Higher Order Validators
   *
   * validators which take other validators as input
   * and output a new validator
   */
  v.shape = function shape(validatorObj) {
    var validators = objectEntries(validatorObj);
    return function shapeValidator(value) {
      var validationResult = validate(v.plainObject, value);

      if (validationResult) {
        return validationResult;
      }

      var key, validator;
      var errorMessages = [];

      for (var i = 0; i < validators.length; i++) {
        key = validators[i].key;
        validator = validators[i].value;
        validationResult = validate(validator, value[key]);

        if (validationResult) {
          // return [key].concat(validationResult);
          errorMessages.push([key].concat(validationResult));
        }
      }

      if (errorMessages.length < 2) {
        return errorMessages[0];
      }

      // enumerate all the error messages
      return function(options) {
        var indent = '\n      ';
        errorMessages = errorMessages.map(function(message) {
          return (
            '>' +
            message[0] +
            ': ' +
            processMessage(message, options)
              .split('\n')
              .join(indent) // indents any inner nesting
          );
        });

        return (
          'The following keys of ' +
          options.path.join('.') +
          ' did not pass validation:' +
          '\n' +
          indent +
          errorMessages.join('\n' + indent)
        );
      };
    };
  };

  v.arrayOf = function arrayOf(validator) {
    return function arrayOfValidator(value) {
      var validationResult = validate(v.plainArray, value);

      if (validationResult) {
        return validationResult;
      }

      for (var i = 0; i < value.length; i++) {
        validationResult = validate(validator, value[i]);

        if (validationResult) {
          return [i].concat(validationResult);
        }
      }
    };
  };

  v.required = function required(validator) {
    function requiredValidator(value) {
      if (value == null) {
        return function(options) {
          return formatErrorMessage(
            options,
            isArrayCulprit(options.path)
              ? 'cannot be undefined/null.'
              : 'is required.'
          );
        };
      }
      return validator.apply(this, arguments);
    }
    requiredValidator.__required = true;

    return requiredValidator;
  };

  v.oneOfType = function oneOfType() {
    var validators = Array.isArray(arguments[0])
      ? arguments[0]
      : Array.prototype.slice.call(arguments);
    return function oneOfTypeValidator(value) {
      var messages = validators
        .map(function(validator) {
          return validate(validator, value);
        })
        .filter(function(message) {
          return !!message;
        });

      // If we don't have as many messages as no. of validators,
      // then at least one validator was ok with the value.
      if (messages.length !== validators.length) {
        return;
      }

      // check primitive type
      if (
        messages.every(function(message) {
          return message.length === 1 && typeof message[0] === 'string';
        })
      ) {
        return orList(
          messages.map(function(m) {
            return m[0];
          })
        );
      }

      // Complex oneOfTypes like
      // `v.oneOftypes(v.shape({name: v.string})`, `v.shape({name: v.number}))`
      // are complex ¯\_(ツ)_/¯. For the current scope only returning the longest message.
      return messages.reduce(function(max, arr) {
        return arr.length > max.length ? arr : max;
      });
    };
  };

  /**
   * Meta Validators
   * which take options as argument (not validators)
   * and return a new primitive validator
   */
  v.equal = function equal(compareWith) {
    return function equalValidator(value) {
      if (value !== compareWith) {
        return JSON.stringify(compareWith);
      }
    };
  };

  v.oneOf = function oneOf() {
    var options = Array.isArray(arguments[0])
      ? arguments[0]
      : Array.prototype.slice.call(arguments);
    var validators = options.map(function(value) {
      return v.equal(value);
    });

    return v.oneOfType.apply(this, validators);
  };

  v.range = function range(compareWith) {
    var min = compareWith[0];
    var max = compareWith[1];
    return function rangeValidator(value) {
      var validationResult = validate(v.number, value);

      if (validationResult || value < min || value > max) {
        return 'number between ' + min + ' & ' + max + ' (inclusive)';
      }
    };
  };

  /**
   * Primitive validators
   *
   * simple validators which return a string or undefined
   */
  v.boolean = function boolean(value) {
    if (typeof value !== 'boolean') {
      return 'boolean';
    }
  };

  v.number = function number(value) {
    if (typeof value !== 'number') {
      return 'number';
    }
  };

  v.plainArray = function plainArray(value) {
    if (!Array.isArray(value)) {
      return 'array';
    }
  };

  v.plainObject = function plainObject(value) {
    if (!isPlainObj(value)) {
      return 'object';
    }
  };

  v.string = function string(value) {
    if (typeof value !== 'string') {
      return 'string';
    }
  };

  v.date = function date(value) {
    var msg = 'date';
    if (typeof value === 'boolean') {
      return msg;
    }
    try {
      var date = new Date(value);
      if (date.getTime && isNaN(date.getTime())) {
        return msg;
      }
    } catch (e) {
      return msg;
    }
  };

  v.coordinates = function coordinates(value) {
    var validationResult =
      validate(v.arrayOf(v.number), value) ||
      validate(v.range([-180, 180]), value[0]) ||
      validate(v.range([-90, 90]), value[1]);

    if (validationResult || value.length !== 2) {
      return 'array of [longitude, latitude]';
    }
  };

  function validate(validator, value) {
    // assertions are optional by default unless wrapped in v.require
    if (value == null && !validator.hasOwnProperty('__required')) {
      return;
    }

    var result = validator(value);

    if (result) {
      return Array.isArray(result) ? result : [result];
    }
  }

  function processMessage(message, options) {
    // message array follows the convention
    // [...path, result]
    // path is an array of object keys / array indices
    // result is output of the validator
    var len = message.length;

    var result = message[len - 1];
    var path = message.slice(0, len - 1);

    if (path.length === 0) {
      // Calling it value since there is no identifiable path
      path = ['value'];
    }
    options = immutable(options, { path: path });

    return typeof result === 'function'
      ? result(options) // allows customization of result
      : formatErrorMessage(options, prettifyResult(result));
  }

  function orList(list) {
    if (list.length < 2) {
      return list[0];
    }
    return [list.slice(0, list.length - 1).join(', ')]
      .concat(list.slice(list.length - 1))
      .join(' or ');
  }

  function prettifyResult(result) {
    return 'must be ' + (/^[aeiou]/.test(result) ? 'an ' : 'a ') + result + '.';
  }

  function formatErrorMessage(options, prettyResult) {
    var arrayCulprit = isArrayCulprit(options.path);
    var output = options.path.join('.') + ' ' + prettyResult;
    var prepend = arrayCulprit ? 'Item at position ' : '';

    return prepend + output;
  }

  function isArrayCulprit(path) {
    return typeof path[path.length - 1] == 'number' || typeof path[0] == 'number';
  }

  function objectEntries(obj) {
    return Object.keys(obj || {}).map(function(key) {
      return { key: key, value: obj[key] };
    });
  }

  v.validate = validate;
  v.processMessage = processMessage;

  var validator = v;

  function file(value) {
    // If we're in a browser so Blob is available, the file must be that.
    // In Node, however, it could be a filepath or a pipeable (Readable) stream.
    if (typeof window !== 'undefined') {
      if (value instanceof commonjsGlobal.Blob || value instanceof commonjsGlobal.ArrayBuffer) {
        return;
      }
      return 'Blob or ArrayBuffer';
    }
    if (typeof value === 'string' || value.pipe !== undefined) {
      return;
    }
    return 'Filename or Readable stream';
  }

  function assertShape(validatorObj, apiName) {
    return validator.assert(validator.shape(validatorObj), apiName);
  }

  var validator$1 = immutable(validator, {
    file: file,
    assertShape: assertShape
  });

  /**
   * Create a new object by picking properties off an existing object.
   * The second param can be overloaded as a callback for
   * more fine grained picking of properties.
   * @param {Object} source
   * @param {Array<string>|function(string, Object):boolean} keys
   * @returns {Object}
   */
  function pick(source, keys) {
    var filter = function(key, val) {
      return keys.indexOf(key) !== -1 && val !== undefined;
    };

    if (typeof keys === 'function') {
      filter = keys;
    }

    return Object.keys(source)
      .filter(function(key) {
        return filter(key, source[key]);
      })
      .reduce(function(result, key) {
        result[key] = source[key];
        return result;
      }, {});
  }

  var pick_1 = pick;

  // This will create the environment-appropriate client.


  function createServiceFactory(ServicePrototype) {
    return function(clientOrConfig) {
      var client;
      if (mapiClient.prototype.isPrototypeOf(clientOrConfig)) {
        client = clientOrConfig;
      } else {
        client = browserClient(clientOrConfig);
      }
      var service = Object.create(ServicePrototype);
      service.client = client;
      return service;
    };
  }

  var createServiceFactory_1 = createServiceFactory;

  /**
   * Datasets API service.
   *
   * Learn more about this service and its responses in
   * [the HTTP service documentation](https://www.mapbox.com/api-documentation/#datasets).
   */
  var Datasets = {};

  /**
   * List datasets in your account.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#list-datasets).
   *
   * @return {MapiRequest}
   */
  Datasets.listDatasets = function() {
    return this.client.createRequest({
      method: 'GET',
      path: '/datasets/v1/:ownerId'
    });
  };

  /**
   * Create a new, empty dataset.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#create-dataset).
   *
   * @param {Object} config
   * @param {string} [config.name]
   * @param {string} [config.description]
   * @return {MapiRequest}
   */
  Datasets.createDataset = function(config) {
    validator$1.assertShape({
      name: validator$1.string,
      description: validator$1.string
    })(config);

    return this.client.createRequest({
      method: 'POST',
      path: '/datasets/v1/:ownerId',
      body: config
    });
  };

  /**
   * Get metadata about a dataset.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#retrieve-a-dataset).
   *
   * @param {Object} config
   * @param {string} config.datasetId
   * @return {MapiRequest}
   */
  Datasets.getMetadata = function(config) {
    validator$1.assertShape({
      datasetId: validator$1.required(validator$1.string),
      description: validator$1.string
    })(config);

    return this.client.createRequest({
      method: 'GET',
      path: '/datasets/v1/:ownerId/:datasetId',
      params: config
    });
  };

  /**
   * Update user-defined properties of a dataset's metadata.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#update-a-dataset).
   *
   * @param {Object} config
   * @param {string} config.datasetId
   * @param {string} [config.name]
   * @param {string} [config.description]
   * @return {MapiRequest}
   */
  Datasets.updateMetadata = function(config) {
    validator$1.assertShape({
      datasetId: validator$1.required(validator$1.string),
      name: validator$1.string,
      description: validator$1.string
    })(config);

    return this.client.createRequest({
      method: 'PATCH',
      path: '/datasets/v1/:ownerId/:datasetId',
      params: pick_1(config, ['datasetId']),
      body: pick_1(config, ['name', 'description'])
    });
  };

  /**
   * Delete a dataset, including all features it contains.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#delete-a-dataset).
   *
   * @param {Object} config
   * @param {string} config.datasetId
   * @return {MapiRequest}
   */
  Datasets.deleteDataset = function(config) {
    validator$1.assertShape({
      datasetId: validator$1.required(validator$1.string)
    })(config);

    return this.client.createRequest({
      method: 'DELETE',
      path: '/datasets/v1/:ownerId/:datasetId',
      params: config
    });
  };

  /**
   * List features in a dataset.
   *
   * This endpoint supports pagination. Use `MapiRequest#eachPage` or manually specify
   * the `limit` and `start` options.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#list-features).
   *
   * @param {Object} config
   * @param {string} config.datasetId
   * @param {number} [config.limit] - Only list this number of features.
   * @param {string} [config.start] - The ID of the feature from which the listing should
   *   start.
   * @return {MapiRequest}
   */
  Datasets.listFeatures = function(config) {
    validator$1.assertShape({
      datasetId: validator$1.required(validator$1.string),
      limit: validator$1.number,
      start: validator$1.string
    })(config);

    return this.client.createRequest({
      method: 'GET',
      path: '/datasets/v1/:ownerId/:datasetId/features',
      params: pick_1(config, ['datasetId']),
      query: pick_1(config, ['limit', 'start'])
    });
  };

  /**
   * Add a feature to a dataset or update an existing one.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#insert-or-update-a-feature).
   *
   * @param {Object} config
   * @param {string} config.datasetId
   * @param {string} config.featureId
   * @param {Object} config.feature - Valid GeoJSON that is not a `FeatureCollection`.
   *   If the feature has a top-level `id` property, it must match the `featureId` you specify.
   * @return {MapiRequest}
   */
  Datasets.putFeature = function(config) {
    validator$1.assertShape({
      datasetId: validator$1.required(validator$1.string),
      featureId: validator$1.required(validator$1.string),
      feature: validator$1.required(validator$1.plainObject)
    })(config);

    if (
      config.feature.id !== undefined &&
      config.feature.id !== config.featureId
    ) {
      throw new Error('featureId must match the id property of the feature');
    }

    return this.client.createRequest({
      method: 'PUT',
      path: '/datasets/v1/:ownerId/:datasetId/features/:featureId',
      params: pick_1(config, ['datasetId', 'featureId']),
      body: config.feature
    });
  };

  /**
   * Get a feature in a dataset.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#retrieve-a-feature).
   *
   * @param {Object} config
   * @param {string} config.datasetId
   * @param {string} config.featureId
   * @return {MapiRequest}
   */
  Datasets.getFeature = function(config) {
    validator$1.assertShape({
      datasetId: validator$1.required(validator$1.string),
      featureId: validator$1.required(validator$1.string)
    })(config);

    return this.client.createRequest({
      method: 'GET',
      path: '/datasets/v1/:ownerId/:datasetId/features/:featureId',
      params: config
    });
  };

  /**
   * Delete a feature in a dataset.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#delete-a-feature).
   *
   * @param {Object} config
   * @param {string} config.datasetId
   * @param {string} config.featureId
   * @return {MapiRequest}
   */
  Datasets.deleteFeature = function(config) {
    validator$1.assertShape({
      datasetId: validator$1.required(validator$1.string),
      featureId: validator$1.required(validator$1.string)
    })(config);

    return this.client.createRequest({
      method: 'DELETE',
      path: '/datasets/v1/:ownerId/:datasetId/features/:featureId',
      params: config
    });
  };

  var datasets = createServiceFactory_1(Datasets);

  function objectClean(obj) {
    return pick_1(obj, function(_, val) {
      return val != null;
    });
  }

  var objectClean_1 = objectClean;

  function objectMap(obj, cb) {
    return Object.keys(obj).reduce(function(result, key) {
      result[key] = cb(key, obj[key]);
      return result;
    }, {});
  }

  var objectMap_1 = objectMap;

  /**
   * Stringify all the boolean values in an object, so true becomes "true".
   *
   * @param {Object} obj
   * @returns {Object}
   */
  function stringifyBoolean(obj) {
    return objectMap_1(obj, function(_, value) {
      return typeof value === 'boolean' ? JSON.stringify(value) : value;
    });
  }

  var stringifyBooleans = stringifyBoolean;

  /**
   * Directions API service.
   *
   * Learn more about this service and its responses in
   * [the HTTP service documentation](https://www.mapbox.com/api-documentation/#directions).
   */
  var Directions = {};

  /**
   * Get directions.
   *
   * Please read [the full HTTP service documentation](https://www.mapbox.com/api-documentation/#directions)
   * to understand all of the available options.
   *
   * @param {Object} config
   * @param {'driving-traffic'|'driving'|'walking'|'cycling'} [config.profile="driving"]
   * @param {Array<DirectionsWaypoint>} config.waypoints - An ordered array of [`DirectionsWaypoint`](#directionswaypoint) objects, between 2 and 25 (inclusive).
   * @param {boolean} [config.alternatives=false] - Whether to try to return alternative routes.
   * @param {Array<'duration'|'distance'|'speed'|'congestion'>} [config.annotations] - Specify additional metadata that should be returned.
   * @param {boolean} [config.bannerInstructions=false] - Should be used in conjunction with `steps`.
   * @param {boolean} [config.continueStraight] - Sets the allowed direction of travel when departing intermediate waypoints.
   * @param {string} [config.exclude] - Exclude certain road types from routing. See HTTP service documentation for options.
   * @param {'geojson'|'polyline'|'polyline6'} [config.geometries="polyline"] - Format of the returned geometry.
   * @param {string} [config.language="en"] - Language of returned turn-by-turn text instructions.
   *   See options listed in [the HTTP service documentation](https://www.mapbox.com/api-documentation/#instructions-languages).
   * @param {'simplified'|'full'|'false'} [config.overview="simplified"] - Type of returned overview geometry.
   * @param {boolean} [config.roundaboutExits=false] - Emit insbtructions at roundabout exits.
   * @param {boolean} [config.steps=false] - Whether to return steps and turn-by-turn instructions.
   * @param {boolean} [config.voiceInstructions=false] - Whether or not to return SSML marked-up text for voice guidance along the route.
   * @param {'imperial'|'metric'} [config.voiceUnits="imperial"] - Which type of units to return in the text for voice instructions.
   * @return {MapiRequest}
   */
  Directions.getDirections = function(config) {
    validator$1.assertShape({
      profile: validator$1.oneOf('driving-traffic', 'driving', 'walking', 'cycling'),
      waypoints: validator$1.required(
        validator$1.arrayOf(
          validator$1.shape({
            coordinates: validator$1.required(validator$1.coordinates),
            approach: validator$1.oneOf('unrestricted', 'curb'),
            bearing: validator$1.arrayOf(validator$1.range([0, 360])),
            radius: validator$1.oneOfType(validator$1.number, validator$1.equal('unlimited')),
            waypointName: validator$1.string
          })
        )
      ),
      alternatives: validator$1.boolean,
      annotations: validator$1.arrayOf(
        validator$1.oneOf('duration', 'distance', 'speed', 'congestion')
      ),
      bannerInstructions: validator$1.boolean,
      continueStraight: validator$1.boolean,
      exclude: validator$1.string,
      geometries: validator$1.string,
      language: validator$1.string,
      overview: validator$1.string,
      roundaboutExits: validator$1.boolean,
      steps: validator$1.boolean,
      voiceInstructions: validator$1.boolean,
      voiceUnits: validator$1.string
    })(config);

    config.profile = config.profile || 'driving';

    var path = {
      coordinates: [],
      approach: [],
      bearing: [],
      radius: [],
      waypointName: []
    };

    var waypointCount = config.waypoints.length;
    if (waypointCount < 2 || waypointCount > 25) {
      throw new Error(
        'waypoints must include between 2 and 25 DirectionsWaypoints'
      );
    }

    /**
     * @typedef {Object} DirectionsWaypoint
     * @property {Coordinates} coordinates
     * @property {'unrestricted'|'curb'} [approach="unrestricted"] - Used to indicate how requested routes consider from which side of the road to approach the waypoint.
     * @property {[number, number]} [bearing] - Used to filter the road segment the waypoint will be placed on by direction and dictates the angle of approach.
     *   This option should always be used in conjunction with a `radius`. The first value is an angle clockwise from true north between 0 and 360,
     *   and the second is the range of degrees the angle can deviate by.
     * @property {number|'unlimited'} [radius] - Maximum distance in meters that the coordinate is allowed to move when snapped to a nearby road segment.
     * @property {string} [waypointName] - Custom name for the waypoint used for the arrival instruction in banners and voice instructions.
     */
    config.waypoints.forEach(function(waypoint) {
      path.coordinates.push(
        waypoint.coordinates[0] + ',' + waypoint.coordinates[1]
      );

      // join props which come in pairs
      ['bearing'].forEach(function(prop) {
        if (waypoint.hasOwnProperty(prop) && waypoint[prop] != null) {
          waypoint[prop] = waypoint[prop].join(',');
        }
      });

      ['approach', 'bearing', 'radius', 'waypointName'].forEach(function(prop) {
        if (waypoint.hasOwnProperty(prop) && waypoint[prop] != null) {
          path[prop].push(waypoint[prop]);
        } else {
          path[prop].push('');
        }
      });
    });

    ['approach', 'bearing', 'radius', 'waypointName'].forEach(function(prop) {
      // avoid sending params which are all `;`
      if (
        path[prop].every(function(char) {
          return char === '';
        })
      ) {
        delete path[prop];
      } else {
        path[prop] = path[prop].join(';');
      }
    });

    var query = stringifyBooleans({
      alternatives: config.alternatives,
      annotations: config.annotations,
      banner_instructions: config.bannerInstructions,
      continue_straight: config.continueStraight,
      exclude: config.exclude,
      geometries: config.geometries,
      language: config.language,
      overview: config.overview,
      roundabout_exits: config.roundaboutExits,
      steps: config.steps,
      voice_instructions: config.voiceInstructions,
      voice_units: config.voiceUnits,
      approaches: path.approach,
      bearings: path.bearing,
      radiuses: path.radius,
      waypoint_names: path.waypointName
    });

    return this.client.createRequest({
      method: 'GET',
      path: '/directions/v5/mapbox/:profile/:coordinates',
      params: {
        profile: config.profile,
        coordinates: path.coordinates.join(';')
      },
      query: objectClean_1(query)
    });
  };

  var directions = createServiceFactory_1(Directions);

  /**
   * Styles API service.
   *
   * Learn more about this service and its responses in
   * [the HTTP service documentation](https://www.mapbox.com/api-documentation/#styles).
   */
  var Styles = {};

  /**
   * Get a style.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#retrieve-a-style).
   *
   * @param {Object} config
   * @param {string} config.styleId
   * @param {string} [config.ownerId]
   * @return {MapiRequest}
   */
  Styles.getStyle = function(config) {
    validator$1.assertShape({
      styleId: validator$1.required(validator$1.string),
      ownerId: validator$1.string
    })(config);

    return this.client.createRequest({
      method: 'GET',
      path: '/styles/v1/:ownerId/:styleId',
      params: config
    });
  };

  /**
   * Create a style.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#create-a-style).
   *
   * @param {Object} config
   * @param {Object} config.style - Stylesheet JSON object.
   * @param {string} [config.ownerId]
   * @return {MapiRequest}
   */
  Styles.createStyle = function(config) {
    validator$1.assertShape({
      style: validator$1.plainObject,
      ownerId: validator$1.string
    })(config);

    return this.client.createRequest({
      method: 'POST',
      path: '/styles/v1/:ownerId',
      params: pick_1(config, ['ownerId']),
      body: config.style
    });
  };

  /**
   * Update a style.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#update-a-style).
   *
   * @param {Object} config
   * @param {string} config.styleId
   * @param {Object} config.style - Stylesheet JSON object.
   * @param {string | number | Date} [config.lastKnownModification] - Datetime of last
   *   known update. Passed as 'If-Unmodified-Since' HTTP header.
   * @param {string} [config.ownerId]
   * @return {MapiRequest}
   */
  Styles.updateStyle = function(config) {
    validator$1.assertShape({
      styleId: validator$1.required(validator$1.string),
      style: validator$1.required(validator$1.plainObject),
      lastKnownModification: validator$1.date,
      ownerId: validator$1.string
    })(config);

    var headers = {};
    if (config.lastKnownModification) {
      headers['If-Unmodified-Since'] = new Date(
        config.lastKnownModification
      ).toUTCString();
    }
    return this.client.createRequest({
      method: 'PATCH',
      path: '/styles/v1/:ownerId/:styleId',
      params: pick_1(config, ['styleId', 'ownerId']),
      headers: headers,
      body: config.style
    });
  };

  /**
   * Delete a style.
   *
   * @param {Object} config
   * @param {string} config.styleId
   * @param {string} [config.ownerId]
   * @return {MapiRequest}
   */
  Styles.deleteStyle = function(config) {
    validator$1.assertShape({
      styleId: validator$1.required(validator$1.string),
      ownerId: validator$1.string
    })(config);

    return this.client.createRequest({
      method: 'DELETE',
      path: '/styles/v1/:ownerId/:styleId',
      params: config
    });
  };

  /**
   * List styles in your account.
   *
   * @param {Object} [config]
   * @param {string} [config.start] - The style ID to start at, for paginated results.
   * @param {string} [config.ownerId]
   * @return {MapiRequest}
   */
  Styles.listStyles = function(config) {
    config = config || {};
    validator$1.assertShape({
      start: validator$1.string,
      ownerId: validator$1.string
    })(config);

    var query = {};
    if (config.start) {
      query.start = config.start;
    }
    return this.client.createRequest({
      method: 'GET',
      path: '/styles/v1/:ownerId',
      params: pick_1(config, ['ownerId']),
      query: query
    });
  };

  /**
   * Add an icon to a style, or update an existing one.
   *
   * @param {Object} config
   * @param {string} config.styleId
   * @param {string} config.iconId
   * @param {UploadableFile} config.file - An SVG file.
   * @param {string} [config.ownerId]
   * @return {MapiRequest}
   */
  Styles.putStyleIcon = function(config) {
    validator$1.assertShape({
      styleId: validator$1.required(validator$1.string),
      iconId: validator$1.required(validator$1.string),
      file: validator$1.file,
      ownerId: validator$1.string
    })(config);

    return this.client.createRequest({
      method: 'PUT',
      path: '/styles/v1/:ownerId/:styleId/sprite/:iconId',
      params: pick_1(config, ['ownerId', 'styleId', 'iconId']),
      file: config.file
    });
  };

  /**
   * Remove an icon from a style.
   *
   * @param {Object} config
   * @param {string} config.styleId
   * @param {string} config.iconId
   * @param {string} [config.ownerId]
   * @return {MapiRequest}
   */
  Styles.deleteStyleIcon = function(config) {
    validator$1.assertShape({
      styleId: validator$1.required(validator$1.string),
      iconId: validator$1.required(validator$1.string),
      ownerId: validator$1.string
    })(config);

    return this.client.createRequest({
      method: 'DELETE',
      path: '/styles/v1/:ownerId/:styleId/sprite/:iconId',
      params: config
    });
  };

  /**
   * Get a style sprite's image or JSON document.
   *
   * See [the corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/?language=JavaScript#retrieve-a-sprite-image-or-json).
   *
   * @param {Object} config
   * @param {string} config.styleId
   * @param {'json' | 'png'} [config.format="json"]
   * @param {boolean} [config.highRes] - If true, returns spritesheet with 2x
   *   resolution.
   * @param {string} [config.ownerId]
   * @return {MapiRequest}
   */
  Styles.getStyleSprite = function(config) {
    validator$1.assertShape({
      styleId: validator$1.required(validator$1.string),
      format: validator$1.oneOf('json', 'png'),
      highRes: validator$1.boolean,
      ownerId: validator$1.string
    })(config);

    var format = config.format || 'json';
    var fileName = 'sprite' + (config.highRes ? '@2x' : '') + '.' + format;

    return this.client.createRequest({
      method: 'GET',
      path: '/styles/v1/:ownerId/:styleId/:fileName',
      params: immutable(pick_1(config, ['ownerId', 'styleId']), {
        fileName: fileName
      })
    });
  };

  /**
   * Get a font glyph range.
   *
   * See [the corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/?language=JavaScript#retrieve-font-glyph-ranges).
   *
   * @param {Object} config
   * @param {string|Array<string>} config.fonts - An array of font names.
   * @param {number} config.start - Character code of the starting glyph.
   * @param {number} config.end - Character code of the last glyph,
   *   typically equivalent to`config.start + 255`.
   * @param {string} [config.ownerId]
   * @return {MapiRequest}
   */
  Styles.getFontGlyphRange = function(config) {
    validator$1.assertShape({
      fonts: validator$1.required(validator$1.oneOfType(validator$1.string, validator$1.arrayOf(validator$1.string))),
      start: validator$1.required(validator$1.number),
      end: validator$1.required(validator$1.number),
      ownerId: validator$1.string
    })(config);

    var fileName = config.start + '-' + config.end + '.pbf';

    return this.client.createRequest({
      method: 'GET',
      path: '/fonts/v1/:ownerId/:fontList/:fileName',
      params: immutable(pick_1(config, ['ownerId']), {
        fontList: [].concat(config.fonts),
        fileName: fileName
      })
    });
  };

  /**
   * Get embeddable HTML displaying a map.
   *
   * See [the corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/?language=JavaScript#embed-a-style).
   *
   * @param {Object} config
   * @param {string} styleId
   * @param {boolean} [scrollZoom=true] - If `false`, zooming the map by scrolling will
   *   be disabled.
   * @param {boolean} [title=false] - If `true`, the map's title and owner is displayed
   *   in the upper right corner of the map.
   * @param {ownerId} [ownerId]
   */
  Styles.getEmbeddableHtml = function(config) {
    validator$1.assertShape({
      styleId: validator$1.required(validator$1.string),
      scrollZoom: validator$1.boolean,
      title: validator$1.boolean,
      ownerId: validator$1.string
    })(config);

    var fileName = config.styleId + '.html';
    var query = {};
    if (config.scrollZoom !== undefined) {
      query.zoomwheel = String(config.scrollZoom);
    }
    if (config.title !== undefined) {
      query.title = String(config.title);
    }

    return this.client.createRequest({
      method: 'GET',
      path: '/styles/v1/:ownerId/:fileName',
      params: immutable(pick_1(config, ['ownerId']), {
        fileName: fileName
      }),
      query: query
    });
  };

  var styles = createServiceFactory_1(Styles);

  /**
   * Tilequery API service.
   *
   * Learn more about this service and its responses in
   * [the HTTP service documentation](https://www.mapbox.com/api-documentation/#tilequery).
   */
  var Tilequery = {};

  /**
   * List features within a radius of a point on a map (or several maps).
   *
   * @param {Object} config
   * @param {Array<string>} config.mapIds - The maps being queried.
   *   If you need to composite multiple layers, provide multiple map IDs.
   * @param {Coordinates} config.coordinates - The longitude and latitude to be queried.
   * @param {number} [config.radius=0] - The approximate distance in meters to query for features.
   * @param {number} [config.limit=5] - The number of features to return, between 1 and 50.
   * @param {boolean} [config.dedupe=true] - Whether or not to deduplicate results.
   * @param {'polygon'|'linestring'|'point'} [config.geometry] - Queries for a specific geometry type.
   * @param {Array<string>} [config.layers] - IDs of vector layers to query.
   * @return {MapiRequest}
   */
  Tilequery.listFeatures = function(config) {
    validator$1.assertShape({
      mapIds: validator$1.required(validator$1.arrayOf(validator$1.string)),
      coordinates: validator$1.required(validator$1.coordinates),
      radius: validator$1.number,
      limit: validator$1.range([1, 50]),
      dedupe: validator$1.boolean,
      layers: validator$1.arrayOf(validator$1.string)
    })(config);

    return this.client.createRequest({
      method: 'GET',
      path: '/v4/:mapIds/tilequery/:coordinates.json',
      params: {
        mapIds: config.mapIds,
        coordinates: config.coordinates
      },
      query: pick_1(config, ['radius', 'limit', 'dedupe', 'layers'])
    });
  };

  var tilequery = createServiceFactory_1(Tilequery);

  /**
   * Tilesets API service.
   *
   * Learn more about this service and its responses in
   * [the HTTP service documentation](https://www.mapbox.com/api-documentation/#tilesets).
   */
  var Tilesets = {};

  /**
   * List a user's tilesets.
   *
   * @param {Object} [config]
   * @param {string} [config.ownerId]
   * @return {MapiRequest}
   */
  Tilesets.listTilesets = function(config) {
    validator$1.assertShape({
      ownerId: validator$1.string
    })(config);

    return this.client.createRequest({
      method: 'GET',
      path: '/tilesets/v1/:ownerId',
      params: config
    });
  };

  var tilesets = createServiceFactory_1(Tilesets);

  /**
   * Tokens API service.
   *
   * Learn more about this service and its responses in
   * [the HTTP service documentation](https://www.mapbox.com/api-documentation/#tokens).
   */
  var Tokens = {};

  /**
   * List your access tokens.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#list-tokens).
   *
   * @return {MapiRequest}
   */
  Tokens.listTokens = function() {
    return this.client.createRequest({
      method: 'GET',
      path: '/tokens/v2/:ownerId'
    });
  };

  /**
   * Create a new access token.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#create-token).
   *
   * @param {Object} [config]
   * @param {string} [config.note]
   * @param {Array<string>} [config.scopes]
   * @param {Array<string>} [config.resources]
   * @return {MapiRequest}
   */
  Tokens.createToken = function(config) {
    config = config || {};
    validator$1.assertShape({
      note: validator$1.string,
      scopes: validator$1.arrayOf(validator$1.string),
      resources: validator$1.arrayOf(validator$1.string)
    })(config);

    var body = {};
    body.scopes = config.scopes || [];
    if (config.note !== undefined) {
      body.note = config.note;
    }
    if (config.resources) {
      body.resources = config.resources;
    }

    return this.client.createRequest({
      method: 'POST',
      path: '/tokens/v2/:ownerId',
      params: pick_1(config, ['ownerId']),
      body: body
    });
  };

  /**
   * Create a new temporary access token.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#create-temporary-token).
   *
   * @param {Object} [config]
   * @param {string} [config.expires]
   * @param {Array<string>} [config.scopes]
   * @return {MapiRequest}
   */
  Tokens.createTemporaryToken = function(config) {
    config = config || {};
    validator$1.assertShape({
      expires: validator$1.required(validator$1.date),
      scopes: validator$1.required(validator$1.arrayOf(validator$1.string))
    })(config);

    return this.client.createRequest({
      method: 'POST',
      path: '/tokens/v2/:ownerId',
      params: pick_1(config, ['ownerId']),
      body: {
        expires: new Date(config.expires).toISOString(),
        scopes: config.scopes
      }
    });
  };

  /**
   * Update an access token.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#update-a-token).
   *
   * @param {Object} config
   * @param {string} config.tokenId
   * @param {string} [config.note]
   * @param {Array<string>} [config.scopes]
   * @param {Array<string>} [config.resources]
   * @return {MapiRequest}
   */
  Tokens.updateToken = function(config) {
    validator$1.assertShape({
      tokenId: validator$1.required(validator$1.string),
      note: validator$1.string,
      scopes: validator$1.arrayOf(validator$1.string),
      resources: validator$1.arrayOf(validator$1.string)
    })(config);

    var body = {};
    if (config.scopes) {
      body.scopes = config.scopes;
    }
    if (config.note !== undefined) {
      body.note = config.note;
    }
    if (config.resources) {
      body.resources = config.resources;
    }

    return this.client.createRequest({
      method: 'PATCH',
      path: '/tokens/v2/:ownerId/:tokenId',
      params: pick_1(config, ['ownerId', 'tokenId']),
      body: body
    });
  };

  /**
   * Get data about the client's access token.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#retrieve-a-token).
   *
   * @return {MapiRequest}
   */
  Tokens.getToken = function() {
    return this.client.createRequest({
      method: 'GET',
      path: '/tokens/v2'
    });
  };

  /**
   * Delete an access token.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/?language=cURL#delete-a-token).
   *
   * @param {Object} config
   * @param {string} config.tokenId
   * @return {MapiRequest}
   */
  Tokens.deleteToken = function(config) {
    validator$1.assertShape({
      tokenId: validator$1.required(validator$1.string)
    })(config);

    return this.client.createRequest({
      method: 'DELETE',
      path: '/tokens/v2/:ownerId/:tokenId',
      params: pick_1(config, ['ownerId', 'tokenId'])
    });
  };

  /**
   * List your available scopes. Each item is a metadata
   * object about the scope, not just the string scope.
   *
   * See the [corresponding HTTP service documentation](https://www.mapbox.com/api-documentation/#list-scopes).
   *
   * @return {MapiRequest}
   */
  Tokens.listScopes = function() {
    return this.client.createRequest({
      method: 'GET',
      path: '/scopes/v1/:ownerId'
    });
  };

  var tokens = createServiceFactory_1(Tokens);

  function mapboxSdk(options) {
    var client = browserClient(options);

    client.datasets = datasets(client);
    client.directions = directions(client);
    client.styles = styles(client);
    client.tilequery = tilequery(client);
    client.tilesets = tilesets(client);
    client.tokens = tokens(client);

    return client;
  }

  var bundle = mapboxSdk;

  return bundle;

})));
